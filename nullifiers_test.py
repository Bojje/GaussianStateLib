from GaussianStateClass import *
import numpy as np
modes = 150
runs = 10
squeezing = np.linspace(0, 0.5, runs)
A_modes = [n * 2 - 1 for n in range(1,int(modes/2) + 1)]
B_modes = [n * 2 for n in range(1,int(modes/2) + 1)]

# creating vectors to store the variances for the EPR state
var_q = np.zeros(runs)
var_p = np.zeros(runs)
m_A = 1
m_B = 1
for ii, sq in enumerate(squeezing):
    g = GaussianState(modes=modes)
    # EPR state tests
    for n in A_modes:
        # Squeezing in the position quadrature
        # for modes in channel A
        g.single_mode_squeeze(sq, np.pi, modes=[n])
    # print(n)
    for n in B_modes:
        # Squeezing modes in channel B
        g.single_mode_squeeze(sq, np.pi, modes=[n])
        # Phase rotation in channel B
        g.phase_shift(np.pi / 2, modes=[n])
    # g.plot_wigner_func(start= -4, stop=4, modes=[2])
    # BS1
    for n_a, n_b in zip(A_modes, B_modes):
        g.beam_split(0.5, modes=[n_a, n_b])

    # BS2 with delay
    g.delay(1)
    for n_a, n_b in zip(A_modes, B_modes):
        g.beam_split(0.5, modes=[n_a, n_b])

    NN = 12
    # BS3 with N delay
    g.delay(12)
    for n_a, n_b in zip(A_modes, B_modes):
        # print(n_a, n_b)
        g.beam_split(0.5, modes=[n_a, n_b])
    k = 40
    sig = g.sigma
    i = kA_x[k]
    null_A_k = sig[i, kA_x[k]] + sig[i, kB_x[k]] - sig[i, kA_x[k + 1]] - sig[i, kB_x[k + 1]] - sig[i, kA_x[k + NN]] + sig[i, kB_x[k + NN]] - sig[i, kA_x[k + NN + 1]] + sig[i, kB_x[k + NN + 1]]


    i = kB_x[k]
    null_B_k = sig[i, kA_x[k]] + sig[i, kB_x[k]] - sig[i, kA_x[k + 1]] - sig[i, kB_x[k + 1]] - sig[i, kA_x[k + NN]] + sig[i, kB_x[k + NN]] - sig[i, kA_x[k + NN + 1]] + sig[i, kB_x[k + NN + 1]]


    i = kA_x[k + 1]
    null_A_k1 = -sig[i, kA_x[k]] - sig[i, kB_x[k]] + sig[i, kA_x[k + 1]] + sig[i, kB_x[k + 1]] + sig[i, kA_x[k + NN]] - sig[i, kB_x[k + NN]] + sig[i, kA_x[k + NN + 1]] - sig[i, kB_x[k + NN + 1]]
    # print(abs(null_A_k) + abs(null_B_k) + abs(null_A1_k) + abs(null_AN_k) +
    # abs(null_BN1_k) + abs(null_B1_k) + abs(null_BN_k) + abs(null_AN1_k))


    i = kB_x[k + 1]
    null_B_k1 = -sig[i, kA_x[k]] - sig[i, kB_x[k]] + sig[i, kA_x[k + 1]] + sig[i, kB_x[k + 1]] + sig[i, kA_x[k + NN]] - sig[i, kB_x[k + NN]] + sig[i, kA_x[k + NN + 1]] - sig[i, kB_x[k + NN + 1]]


    i = kA_x[k + NN]
    null_A_kN = -sig[i, kA_x[k]] - sig[i, kB_x[k]] + sig[i, kA_x[k + 1]] + sig[i, kB_x[k + 1]] + sig[i, kA_x[k + NN]] - sig[i, kB_x[k + NN]] + sig[i, kA_x[k + NN + 1]] - sig[i, kB_x[k + NN + 1]]


    i = kB_x[k + NN]
    null_B_kN = sig[i, kA_x[k]] + sig[i, kB_x[k]] - sig[i, kA_x[k + 1]] - sig[i, kB_x[k + 1]] - sig[i, kA_x[k + NN]] + sig[i, kB_x[k + NN]] - sig[i, kA_x[k + NN + 1]] + sig[i, kB_x[k + NN + 1]]


    i = kA_x[k + NN + 1]
    null_A_kN1 = -sig[i, kA_x[k]] - sig[i, kB_x[k]] + sig[i, kA_x[k + 1]] + sig[i, kB_x[k + 1]] + sig[i, kA_x[k + NN]] - sig[i, kB_x[k + NN]] + sig[i, kA_x[k + NN + 1]] - sig[i, kB_x[k + NN + 1]]


    i = kB_x[k + NN + 1]
    null_B_kN1 = sig[i, kA_x[k]] + sig[i, kB_x[k]] - sig[i, kA_x[k + 1]] - sig[i, kB_x[k + 1]] - sig[i, kA_x[k + NN]] + sig[i, kB_x[k + NN]] - sig[i, kA_x[k + NN + 1]] + sig[i, kB_x[k + NN + 1]]


    var_q[ii] = null_A_k + null_B_k + null_A_k1 + null_B_k1 + null_A_kN + null_B_kN + null_A_kN1 + null_B_kN1


# import matplotlib.pyplot as plt
# plt.plot(squeezing, var_p, 'x')
# plt.plot(squeezing, np.exp(-2 * squeezing), label='Expected')
# plt.title('var($\hat{n}^p$) for an EPR state')
# plt.xlabel('Squeezing (r)')
# plt.ylabel('var($\hat{n}^p$)')
# plt.show()


plt.plot(squeezing, var_q, 'x', label='Generated by Gaussian class')
plt.plot(squeezing, 4 * np.exp(-2 * squeezing), label='Expected')
#modes_first = [[i * 2- 2, i * 2 - 1] for i in modes]]
plt.legend()
plt.title('var($\hat{n}^q$) for an EPR state')
plt.xlabel('Squeezing (r)')
plt.ylabel('var($\hat{n}^q$)')
plt.show()
